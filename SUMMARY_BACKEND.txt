# FreeNow Backend - Implementation Summary

This file explains the technical architecture and backend logic that powers the FreeNow experience, following a structured "Implementation & Explanation" format.

---

## üõ†Ô∏è Core Infrastructure

### Implementing Node.js & Express API
**How it is implemented**: Node.js serves as the execution environment, with Express.js managing the RESTful API endpoints. It handles critical tasks such as fetching global stats, user history, and processing feedback submissions.

### Implementing Socket.io (Server)
**How it is implemented**: Socket.io manages all real-time bi-directional communication. It uses namespaces and dynamic "Rooms" to isolate conversations between matched pairs, ensuring message privacy and low-latency feature synchronization.

### Implementing MongoDB Atlas (Cloud)
**How it is implemented**: We utilize a globally distributed MongoDB Atlas cluster to store non-ephemeral data. This includes user profiles, activity logs for statistics, and feedback submissions. We use the official `mongodb` driver for high-performance atomic operations.

### Implementing Automated Maintenance (Cron Jobs)
**How it is implemented**: Using `node-cron`, the server runs scheduled tasks at midnight IST. These tasks rotate daily connection records, cleanup stale session logs, and reset monthly counters to keep the database optimized.

---

## üß† Logic & Engineering

### Implementing 5-Second Refresh Grace Period (Anti-Ghosting)
**How it is implemented**: In the socket `disconnect` handler, we implement a `setTimeout` for 5 seconds. If a new socket with the same `sessionId` connects before the timer ends, the disconnect cleanup is cancelled, allowing users to refresh pages without losing their chat rooms.

### Implementing Real-Time Synchronization Logic
**How it is implemented**: The server acts as a central hub for state changes. When a chat starts or ends, it broadcasts `conversation-started` or `conversation-ended` events to all connected clients, ensuring the landing page's "Talking Now" box is always in sync.

### Implementing Message Action Broadcasting (Edit/Delete)
**How it is implemented**: For edits and deletions, the server receives the target `messageId` and broadcasting the update to only participants in that specific room. This ensures that UI updates happen instantly for both users without storing the messages on the server.

### Implementing Global Stats Engine (Atomic Increments)
**How it is implemented**: To ensure high performance under load, we use MongoDB's `$inc` operator. This allows the server to increment connection counters and peak duration stats atomically, avoiding the need for expensive "count" queries on large datasets.

### Implementing Feedback Collection Engine
**How it is implemented**: A dedicated POST endpoint `/api/feedback` was implemented to bridge the frontend support hub with the database. It validates user input and persists feedback messages for developer review, separating it from the ephemeral chat logic.

### Implementing User Feedback Response Flow
**How it is implemented**: To reply to users, the administrator can access the `feedback` collection in the MongoDB Atlas dashboard. Since every feedback entry includes the user's email address, the administrator can respond directly via email. This maintains the platform's focus on privacy while ensuring a professional support channel.

### Implementing Bilateral Feature Sync (Draw/Game)
**How it is implemented**: State-toggle events like `draw-toggle` and `vibe-game-toggle` are broadcasted to the room. When one user opens a tool, the server tells the other client to open the same tool, ensuring both participants are always looking at the same interface.

### Implementing Stale Session Cleanup (Safety Net)
**How it is implemented**: On server startup and during idle periods, a cleanup logic runs to delete any "Active User" records whose sockets are no longer connected. This prevents "Ghost" users from appearing in the discovery pool.

---

## üõ°Ô∏è Security & Privacy Philosophy
**How it is implemented**: Privacy is implemented by making the database "blind" to conversation content. Message payloads travel through memory only and are never written to disk, upholding the platform's commitment to ephemeral, trace-free communication.
